# 📚 JavaScript Interview Questions & Answers

## Core JavaScript

| No. | Question                                 |
|-----|------------------------------------------|
| 1   | [What is JavaScript?](#question-1--what-is-javascript)                                                                        |
| 2   | [What are JavaScript Data Types?](#question-2-what-are-javascript-data-types)                                                                        |
| 3   | [Difference between == and === in JavaScript?](#question-3-difference-between--and--in-javascript)                                                                        |
| 4   | [What are Truthy and Falsy values?](#question-4-what-are-truthy-and-falsy-values)                                                                        |
| 5   | [What is the difference between var, let, and const?](#question-5-what-is-the-difference-between-var-let-and-const)                                                             |
| 6   | [What is Hoisting in JavaScript? ](#question-6-what-is-hoisting-in-javascript)                                                             |
| 7   | [What is the difference between function declaration and function expression?](#question-7-what-is-the-difference-between-function-declaration-and-function-expression)                                                             |
| 8   | [What are Arrow functions in javaScript?](#question-8-what-are-arrow-functions-in-javascript)                                                             |
| 9   | [What is the difference between null and undefined?](#question-9-what-is-the-difference-between-null-and-undefined)                                                             |
| 10   | [What is the difference between primitive and reference types?](#question-10-what-is-the-difference-between-primitive-and-reference-types)                                                             |
| 11   | [What is the difference between synchronous and asynchronous code?](#question-11-what-is-the-difference-between-synchronous-and-asynchronous-code)                                                             |
| 12   | [What are callbacks in javaScript?](#question-12-what-are-callbacks-in-javascript)                                                             |
| 13   | [What are promises in javaScript?](#question-13-what-are-promises-in-javascript)                                                             |
| 14   | [What is asyncawait in javaScript?](#question-14-what-is-asyncawait-in-javascript)                                                             |
| 15   | [What is an event loop in javaScript?](#question-15-what-is-an-event-loop-in-javascript)                                                             |
| 16   | [What are closures in javaScript?](#question-16-what-are-closures-in-javascript)                                                             |
| 17   | [What is the difference between call, apply and bind?](#question-17-what-is-the-difference-between-call-apply-and-bind)                                                             |
| 18   | [What are template literals in javaScript?](#question-18-what-are-template-literals-in-javascript)                                                             |
| 19   | [What is destructuring in javaScript?](#question-19-what-is-destructuring-in-javascript)                                                             |
| 20   | [What are spread and rest operatores in javaScript?](#question-20-what-are-spread-and-rest-operators-in-javascript)                                                             |
| 21   | [What is a closure?](#question-21-what-is-a-closure)                                                             |
| 22   | [What is the difference between null and undefined?](#question-22-what-is-the-difference-between-null-and-undefined)                                                             |
| 23   | [What are template literals?](#question-23-what-are-template-literals)                                                             |
| 24   | [What is the difference between map, forEach and filter? ](#question-24-what-is-the-difference-between-map-foreach-and-filter)                                                             |
| 25   | [What is event delegation?](#question-25-what-is-event-delegation)                                                             |
| 26   | [What is the defference between function declaration and function expressions?](#question-26-what-is-the-difference-between-function-declaration-and-function-expression)                                                             |
| 27   | [What are arrow functions?](#question-27-what-are-arrow-functions)                                                             |
| 28   | [What is the defference between Call, Apply and Bind?](#question-28-what-is-the-difference-between-call-apply-and-bind)                                                             |
| 29   | [What is this in javaScript?](#question-29-what-is-this-in-javascript)                                                             |
| 30   | [What is the difference between asynchronous and asynchronous javaScript?](#question-30-what-is-the-difference-between-synchronous-and-asynchronous-javascript)                                                             |
| 31   | [What are promises?](#question-31-what-are-promises)                                                             |
| 32   | [What is asyncawait?](#question-32-what-is-asyncawait)                                                             |
| 33   | [What is the difference between localStorage, sessionStorage and cookies?](#question-33-what-is-the-difference-between-localstorage-sessionstorage-and-cookies)                                                             |
| 34   | [What are javaScript modules](#question-34-what-are-javascript-modules)                                                             |
| 35   | [What is an life?](#question-35-what-is-an-iife)                                                             |
| 36   | [What are higher orger functions](#question-36-what-are-higher-order-functions)                                                             |
| 37   | [What is the event loop in javaScript?](#question-37-what-is-the-event-loop-in-javascript)                                                             |
| 38   | [What is debouncing?](#question-38-what-is-debouncing)                                                             |
| 39   | [What is throttling?](#question-39-what-is-throttling)                                                             |
| 40   | [What is the difference between deep copy and shallow copy?](#question-40-what-is-the-difference-between-deep-copy-and-shallow-copy)                                                             |
| 41   | [What is NaN in javaScript?](#question-41-what-is-nan-in-javascript)                                                             |
| 42   | [What is typeOf null in javaScript?](#question-42-what-is-typeof-null-in-javascript)                                                             |
| 43   | [What are generatores?](#question-43-what-are-generators)                                                             |
| 44   | [What are symbols in javaScript?](#question-44-what-are-symbols-in-javascript)                                                             |
| 45   | [What is object destructuring?](#question-45-what-is-object-destructuring)                                                             |
| 46   | [What is the spread operator?](#question-46-what-is-the-spread-operator)                                                             |
| 47   | [What is the rest operator?](#question-47-what-is-the-rest-operator)                                                             |
| 48   | [What is memoization?](#question-48-what-is-memoization)                                                             |
| 49   | [What is currying?](#question-49-what-is-currying)                                                             |
| 50   | [What are polyfills?](#question-50-what-are-polyfills)                                                             |
| 51   | [What is a generator functions](#question-51-what-is-a-generator-function)                                                             |
| 52   | [What is teh difference between for-in and for-of loops?](#question-52-what-is-the-difference-between-forin-and-forof-loops)                                                             |
| 53   | [What is the difference between object freeze and object seal?](#question-53-what-is-the-difference-between-objectfreeze-and-objectseal)                                                             |
| 54   | [What is the difference between setTimeOut and setInterval?](#question-54-what-is-the-difference-between-settimeout-and-setinterval)                                                             |
| 55   | [What is the difference between ==, ===, !=, and !==?](#question-55-what-is-the-difference-between----and-)                                                             |
| 56   | [what is the difference between documentQuerySelector and documentGetelementById?](#question-56-what-is-the-difference-between-documentqueryselector-and-documentgetelementbyid)                                                             |
| 57   | [What is the difference between innerHTML and textContent?](#question-57-what-is-the-difference-between-innerhtml-and-textcontent)                                                             |
| 58   | [What is the difference between == null and === null?](#question-58-what-is-the-difference-between--null-and--null)                                                             |
| 59   | [What is the difference between Call Stack and Task Queue?](#question-59-what-is-the-difference-between-call-stack-and-task-queue)                                                             |
| 60   | [What is the difference between null, undefined, and NaN?](#question-60-what-is-the-difference-between-null-undefined-and-nan)                                                             |
| 61   | [What is the difference between Object.keys, Object.values, and Object.entries?](#question-61-what-is-the-difference-between-objectkeys-objectvalues-and-objectentries)                                                             |
| 62   | [What is the difference between undefined and undeclared?](#question-62-what-is-the-difference-between-undefined-and-undeclared)                                                             |
| 63   | [What is Event Bubbling in JavaScript?](#question-63-what-is-event-bubbling-in-javascript)                                                             |
| 64   | [What is Event Capturing in JavaScript?](#question-64-what-is-event-capturing-in-javascript)                                                             |
| 65   | [What is the difference between filter and find?](#question-65-what-is-the-difference-between-filter-and-find)                                                             |
| 66   | [What is the difference between slice and splice?](#question-66-what-is-the-difference-between-slice-and-splice)                                                             |
| 67   | [What is the difference between default and named exports?](#question-67-what-is-the-difference-between-default-and-named-exports)                                                             |
| 68   | [What is the difference between process.nextTick() and setImmediate() in Node.js?](#question-68-what-is-the-difference-between-processnexttick-and-setimmediate-in-nodejs)                                                             |
| 69   | [What is the difference between == and Object.is()?](#question-69-what-is-the-difference-between--and-objectis)                                                             |
| 70   | [What is the difference between null and 0 in JavaScript?](#question-70-what-is-the-difference-between-null-and-0-in-javascript)                                                             |
| 71   | [What is the difference between var obj1 = {a:1} and var obj2 = Object.create(null)?](#question-71-what-is-the-difference-between-var-obj1--a1-and-var-obj2--objectcreatenull)                                                             |
| 72   | [What is the difference between for..in and Object.keys()?](#question-72-what-is-the-difference-between-forin-and-objectkeys)                                                             |
| 73   | [What is the difference between isNaN() and Number.isNaN()?](#question-73-what-is-the-difference-between-isnan-and-numberisnan)                                                             |
| 74   | [What is the difference between setTimeout(fn, 0) and Promise.resolve().then(fn)?](#question-74-what-is-the-difference-between-settimeoutfn-0-and-promiseresolvethenfn)                                                             |
| 75   | [What is the difference between typeof and instanceof?](#question-75-what-is-the-difference-between-typeof-and-instanceof)                                                             |
| 76   | [What is the difference between hasOwnProperty and in operator?](#question-76-what-is-the-difference-between-hasownproperty-and-in-operator)                                                             |
| 77   | [What is the difference between Object.freeze() and Object.preventExtensions()?](#question-77-what-is-the-difference-between-objectfreeze-and-objectpreventextensions)                                                             |
| 78   | [What is the difference between forEach, map, and reduce?](#question-78-what-is-the-difference-between-foreach-map-and-reduce)                                                             |
| 79   | [What is the difference between call stack and event loop?](#question-79-what-is-the-difference-between-call-stack-and-event-loop)                                                             |
| 80   | [What is the difference between deep equality and shallow equality?](#question-80-what-is-the-difference-between-deep-equality-and-shallow-equality)                                                             |
| 81   | [What is the difference between for..of and forEach?](#question-81-what-is-the-difference-between-forof-and-foreach)                                                             |
| 82   | [What is the difference between Object.create(null) and {}](#question-82-what-is-the-difference-between-objectcreatenull-and-)                                                             |
| 83   | [What is the difference between JSON.stringify and JSON.parse?](#question-83-what-is-the-difference-between-jsonstringify-and-jsonparse)                                                             |
| 84   | [What is the difference between null and NaN?](#question-84-what-is-the-difference-between-null-and-nan)                                                             |
| 85   | [What is the difference between Object.assign() and spread operator {...obj}?](#question-85-what-is-the-difference-between-objectassign-and-spread-operator-obj)                                                             |
| 86   | [What is the difference between Array.from() and Array.of()?](#question-86-what-is-the-difference-between-arrayfrom-and-arrayof)                                                             |
| 87   | [What is the difference between window.onload and DOMContentLoaded?](#question-87-what-is-the-difference-between-windowonload-and-domcontentloaded)                                                             |
| 88   | [What is the difference between flatMap() and map()?](#question-88-what-is-the-difference-between-flatmap-and-map)                                                             |
| 89   | [What is the difference between WeakMap and Map in JavaScript?](#question-89-what-is-the-difference-between-weakmap-and-map-in-javascript)                                                             |
| 90   | [What is the difference between WeakSet and Set?](#question-90-what-is-the-difference-between-weakset-and-set)                                                             |
| 91   | [What is the difference between structuredClone() and JSON.parse(JSON.stringify())?](#question-91-what-is-the-difference-between-structuredclone-and-jsonparsejsonstringify)                                                             |
| 92   | [What is the difference between Event Delegation and Direct Event Handling?](#question-92-what-is-the-difference-between-event-delegation-and-direct-event-handling)                                                             |
| 93   | [What is the difference between Promise.all and Promise.race?](#question-93-what-is-the-difference-between-promiseall-and-promiserace)                                                             |
| 94   | [What is the difference between setTimeout with 0ms delay and Promise.then()?](#question-94-what-is-the-difference-between-settimeout-with-0ms-delay-and-promisethen)                                                             |
| 95   | [What is the difference between flat() and flatMap()?](#question-95-what-is-the-difference-between-flat-and-flatmap)                                                             |
| 96   | [What is the difference between Symbol() and String() as object keys?](#question-96-what-is-the-difference-between-symbol-and-string-as-object-keys)                                                             |
| 97   | [What is the difference between Object.seal() and Object.freeze()?](#question-97-what-is-the-difference-between-objectseal-and-objectfreeze)                                                             |
| 98   | [What are Proxies in JavaScript and their use cases?](#question-98-what-are-proxies-in-javascript-and-their-use-cases)                                                             |
| 99   | [What is the difference between Microtask and Macrotask?](#question-99-what-is-the-difference-between-microtask-and-macrotask)                                                             |
| 100   | [How to optimize performance in large JavaScript applications?](#question-100-how-to-optimize-performance-in-large-javascript-applications)                                                             |

             
## Question 1:  What is JavaScript?
**Answer:** **JavaScript (JS)** is a **high-level, dynamic, interpreted programming language** that enables you to add interactivity, logic, and dynamic behavior to web pages.

###  Key Points:
- JavaScript is single-threaded and asynchronous (via event loop).
- Runs in the browser as well as on the server (via Node.js).
- Supports both object-oriented and functional programming.
- It is loosely typed (dynamic typing).

### Core Features of React:
- **JSX**: JavaScript syntax extension that lets you write HTML inside JavaScript.
- **Virtual DOM**: Optimized way to update the actual DOM only where needed.
- **Components**: Independent and reusable pieces of code.
- **Unidirectional Data Flow**: Data flows in one direction, making state changes predictable.
- **Hooks**: Functions like `useState`, `useEffect` etc., for managing state and lifecycle in functional components.

### 💡 Example Code:

```jsx
console.log("Hello, JavaScript!");
```
### [🔝 Back to Top](#core-javascript)

## Question 2: What are JavaScript Data Types?
**Answer:** JavaScript provides different types of values which are categorized as Primitive and Reference types.

###  Key Points:
- Primitive Types: String, Number, Boolean, Null, Undefined, Symbol, BigInt.
- Reference Types: Object, Array, Function, Date, RegExp, etc.

### 💡 Example Code:

```jsx
let name = "Ritik"; // String
let age = 25; // Number
let isDev = true; // Boolean
let empty = null; // Null
let notDefined; // Undefined
let big = 1234567890n; // BigInt
let user = { name: "Ritik", age: 25 }; // Object
```
### [🔝 Back to Top](#core-javascript)

## Question 3: Difference between == and === in JavaScript?  

**Answer:**  
`==` is the loose equality operator that performs type conversion before comparison.  
`===` is the strict equality operator that checks both value and type without conversion.  

### Key Points:
- Prefer using `===` for accurate and predictable comparisons.  
- `==` can lead to unexpected results due to type coercion.  

### 💡 Example Code:
```js
console.log(5 == "5");   // true (type coercion)
console.log(5 === "5");  // false (type different)
```
### [🔝 Back to Top](#core-javascript)

## Question 4: What are Truthy and Falsy values?  

**Answer:**  
In JavaScript, values are automatically converted to `true` or `false` when evaluated in a boolean context.  

### Key Points:
- **Falsy Values:** `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`  
- **Truthy Values:** Everything else (non-empty strings, objects, arrays, etc.)  

### 💡 Example Code:
```js
if ("") console.log("Truthy"); else console.log("Falsy"); // Falsy
if ("Hello") console.log("Truthy"); // Truthy
```

### [🔝 Back to Top](#core-javascript)

## Question 5: What is the difference between var, let, and const?  

**Answer:**  
These are keywords used to declare variables with different scopes and behaviors.  

### Key Points:
- **var:** Function-scoped, hoisted, can be re-declared.  
- **let:** Block-scoped, not hoisted the same way, cannot be re-declared.  
- **const:** Block-scoped, must be initialized, cannot be reassigned.  

### 💡 Example Code:
```js
var a = 10;
let b = 20;
const c = 30;

// Re-declare
var a = 40; // ✅ Works
// let b = 50; ❌ Error
// const c = 60; ❌ Error
```

### [🔝 Back to Top](#core-javascript)

## Question 6: What is Hoisting in JavaScript?  

**Answer:**  
Hoisting is JavaScript’s behavior of moving variable and function declarations to the top of their scope before execution.  

### Key Points:
- Only declarations are hoisted, not initializations.  
- **var** is hoisted with `undefined`.  
- **let** and **const** are hoisted but kept in a **temporal dead zone (TDZ)**.  

### 💡 Example Code:
```js
console.log(x); // undefined
var x = 5;

// console.log(y); // ❌ ReferenceError (TDZ)
let y = 10;
```

### [🔝 Back to Top](#core-javascript)

## Question 7: What is the difference between function declaration and function expression?  

**Answer:**  
- **Function Declaration:** Hoisted to the top.  
- **Function Expression:** Not hoisted, defined at runtime.  

### Key Points:
- Declarations can be called before definition.  
- Expressions cannot be called before assignment.  

### 💡 Example Code:
```js
// Function Declaration
sayHello(); // ✅ Works
function sayHello() { console.log("Hello"); }

// Function Expression
// greet(); // ❌ Error
const greet = function() { console.log("Hi"); };
```

### [🔝 Back to Top](#core-javascript)

## Question 8: What are Arrow Functions in JavaScript?  

**Answer:**  
Arrow functions provide a shorter syntax to write functions and do not bind their own `this`.  

### Key Points:
- Compact syntax.  
- Lexical `this` (inherits from parent scope).  
- Cannot be used as constructors.  

### 💡 Example Code:
```js
const add = (a, b) => a + b;
console.log(add(5, 3)); // 8
```

### [🔝 Back to Top](#core-javascript)

## Question 9: What is the difference between null and undefined?  

**Answer:**  
- `null` → Intentional absence of value.  
- `undefined` → Variable declared but not assigned.  

### Key Points:
- `typeof null` → `"object"` (JS bug).  
- `typeof undefined` → `"undefined"`.  

### 💡 Example Code:
```js
let a = null;
let b;

console.log(a); // null
console.log(b); // undefined
```

### [🔝 Back to Top](#core-javascript)

## Question 10: What is the difference between Primitive and Reference types?  

**Answer:**  
- **Primitive Types** → Stored directly in memory (immutable).  
- **Reference Types** → Stored by reference (mutable).  

### Key Points:
- Primitive comparison is by value.  
- Objects/arrays are compared by reference.  

### 💡 Example Code:
```js
let x = 10;
let y = 10;
console.log(x === y); // true (value)

let obj1 = { a: 1 };
let obj2 = { a: 1 };
console.log(obj1 === obj2); // false (different references)
```

### [🔝 Back to Top](#core-javascript)

## Question 11: What is the difference between synchronous and asynchronous code?  

**Answer:**  
- **Synchronous code** executes line by line, blocking further execution until the current line finishes.  
- **Asynchronous code** allows tasks to run in the background without blocking the main thread.  

### Key Points:
- JavaScript is single-threaded but uses async operations (`callbacks`, `promises`, `async/await`).  
- Useful for tasks like API calls, timers, file I/O.  

### 💡 Example Code:
```js
console.log("Start");

setTimeout(() => console.log("Async Task"), 1000);

console.log("End");
```

### [🔝 Back to Top](#core-javascript)

## Question 12: What are Callbacks in JavaScript?  

**Answer:**  
A callback is a function passed as an argument to another function and executed later.  

### Key Points:
- Used in async operations.  
- Can cause callback hell if nested deeply.  

### 💡 Example Code:
```js
function greet(name, callback) {
  console.log("Hello, " + name);
  callback();
}

greet("Ritik", () => console.log("Welcome!"));
```

### [🔝 Back to Top](#core-javascript)

## Question 13: What are Promises in JavaScript?  

**Answer:**  
Promises represent the eventual completion or failure of an asynchronous operation.  

### Key Points:
- States: `pending`, `fulfilled`, `rejected`.  
- Methods: `.then()`, `.catch()`, `.finally()`.  

### 💡 Example Code:
```js
let promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) resolve("Done");
  else reject("Error");
});

promise
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .finally(() => console.log("Completed"));
```

### [🔝 Back to Top](#core-javascript)

## Question 14: What is async/await in JavaScript?  

**Answer:**  
`async/await` is syntactic sugar over promises, making asynchronous code look synchronous.  

### Key Points:
- `async` makes a function return a promise.  
- `await` pauses execution until the promise resolves.  

### 💡 Example Code:
```js
async function fetchData() {
  let data = await new Promise(res => 
    setTimeout(() => res("Data received"), 1000)
  );
  console.log(data);
}

fetchData();
```

### [🔝 Back to Top](#core-javascript)

## Question 15: What is an Event Loop in JavaScript?  

**Answer:**  
The **event loop** continuously checks the **call stack** and the **callback queue**, pushing async tasks into the call stack when it’s empty.  

### Key Points:
- Enables **non-blocking async execution**.  
- Works with the **callback queue** and **microtask queue**.  

### 💡 Example Code:
```js
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");

// Output: Start -> End -> Promise -> Timeout
```

### [🔝 Back to Top](#core-javascript)

## Question 16: What are Closures in JavaScript?

**Answer:**  
A **closure** is a function that retains access to variables from its **outer scope** even after the outer function has executed.  

### Key Points:
- Used for **data privacy** and **stateful functions**.  
- The **inner function remembers** variables from the outer scope.  

### 💡 Example Code:
```js
function outer() {
  let count = 0;

  return function inner() {
    count++;
    return count;
  };
}

const counter = outer();

console.log(counter()); // 1
console.log(counter()); // 2
```

### [🔝 Back to Top](#core-javascript)

## Question 17: What is the difference between `call`, `apply`, and `bind`?

**Answer:**  
All three are used to explicitly set the `this` context of a function.

### Key Points:
- **`call`** → Invokes function **immediately**, arguments passed **individually (comma-separated)**.  
- **`apply`** → Invokes function **immediately**, arguments passed as a **single array**.  
- **`bind`** → Does **not call immediately**, returns a **new function** with `this` bound.

### 💡 Example Code:
```js
function greet(msg) {
  console.log(msg + ", " + this.name);
}

const user = { name: "Ritik" };

// call → arguments separated by commas
greet.call(user, "Hello"); // Hello, Ritik

// apply → arguments passed as array
greet.apply(user, ["Hi"]); // Hi, Ritik

// bind → returns new function
const bound = greet.bind(user, "Hey");
bound(); // Hey, Ritik
```

### [🔝 Back to Top](#core-javascript)

## Question 18: What are Template Literals in JavaScript?

**Answer:**  
Template literals are string literals that use **backticks (`` ` ``)** instead of quotes, allowing embedded expressions and multiline strings.

### Key Points:
- Allow **string interpolation** with `${expression}`.  
- Support **multiline strings** without `\n`.  
- Can also use **tagged templates** for custom processing.

### 💡 Example Code:
```js
let name = "Ritik";
let age = 25;

// String interpolation
console.log(`Hello, ${name}! You are ${age} years old.`);

// Multiline string
let msg = `This is
a string
across multiple lines.`;
console.log(msg);
```

### [🔝 Back to Top](#core-javascript)

## Question 19: What is Destructuring in JavaScript?

**Answer:**  
Destructuring is a feature in JavaScript that allows you to **unpack values** from arrays or **extract properties** from objects into distinct variables.

### Key Points:
- Simplifies assignments and improves readability.  
- Works with **arrays, objects, nested structures, default values, and renaming**.  
- Helps avoid repetitive code like `obj.name`, `obj.age`.

### 💡 Example Code:
```js
// Array destructuring
const arr = [10, 20, 30];
const [a, b] = arr;
console.log(a, b); // 10 20

// Object destructuring
const obj = { name: "Ritik", age: 25 };
const { name, age } = obj;
console.log(name, age); // Ritik 25

// With default values
const [x, y, z = 100] = [1, 2];
console.log(x, y, z); // 1 2 100

// Renaming variables
const { name: userName } = obj;
console.log(userName); // Ritik
```

### [🔝 Back to Top](#core-javascript)

## Question 20: What are Spread and Rest Operators in JavaScript?

**Answer:**  
Both operators use `...` (three dots) but serve **different purposes**.

---

### Key Points:
- **Spread (`...`)** → Expands/unwraps elements of an **array or object**.  
- **Rest (`...`)** → Collects remaining arguments into an **array**.  
- Spread is used in function calls, array/object literals.  
- Rest is used in function parameters or destructuring.  

---

### 💡 Example Code:

```js
// Spread Example (Expanding)
let arr = [1, 2, 3];
let newArr = [...arr, 4, 5];
console.log(newArr); // [1, 2, 3, 4, 5]

let obj = { name: "Ritik", age: 25 };
let newObj = { ...obj, country: "India" };
console.log(newObj); // { name: "Ritik", age: 25, country: "India" }

// Rest Example (Collecting)
function sum(...nums) {
  return nums.reduce((a, b) => a + b, 0);
}
console.log(sum(1, 2, 3, 4)); // 10

// Rest with Destructuring
const [first, ...rest] = [10, 20, 30, 40];
console.log(first); // 10
console.log(rest);  // [20, 30, 40]
```

### [🔝 Back to Top](#core-javascript)

## Question 21: What is a Closure?

**Answer:**  
A **closure** is created when an inner function "remembers" the variables from its outer (lexical) scope, even after the outer function has executed.  

---

### Key Points:
- Functions in JavaScript form closures automatically.  
- Useful for **data privacy**, **encapsulation**, and creating **stateful functions**.  
- Inner function always has access to:  
  1. Its own variables.  
  2. Outer function variables.  
  3. Global variables.  

---

### 💡 Example Code:
```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  };
}

const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

### [🔝 Back to Top](#core-javascript)

## Question 22: What is the difference between null and undefined?

**Answer:**  
- **undefined** → A variable that is declared but not assigned any value.  
- **null** → An assignment value that represents “nothing” or “empty”.

---

### Key Points:
- `undefined` is set by **JavaScript itself**.  
- `null` is set **explicitly by the programmer**.  
- `typeof undefined` → `"undefined"`  
- `typeof null` → `"object"` (this is a known JavaScript bug).  

---

### 💡 Example Code:
```js
let a;
console.log(a);        // undefined

let b = null;
console.log(b);        // null

console.log(typeof a); // "undefined"
console.log(typeof b); // "object"
```

### [🔝 Back to Top](#core-javascript)

## Question 23: What are Template Literals?

**Answer:**  
Template literals allow embedding variables and expressions inside strings using backticks (`` ` ``).  

---

### Key Points:
- Use backticks instead of single (`'`) or double (`"`) quotes.  
- Support **string interpolation** using `${}`.  
- Allow **multi-line strings** without `\n`.  
- Can include **expressions & function calls** inside `${}`.  

---

### 💡 Example Code:
```js
let name = "Ritik";
let age = 25;

// String interpolation
console.log(`Hello, ${name}! You are ${age} years old.`);

// Multi-line string
let message = `
This is line 1
This is line 2
`;
console.log(message);

// Expression inside template literal
console.log(`Next year, you will be ${age + 1}`);
```

### [🔝 Back to Top](#core-javascript)

## Question 24: What is the difference between `map`, `forEach`, and `filter`?

**Answer:**  
All three are array iteration methods, but their purpose and return values differ.

---

### Key Points:

- **map()**
  - Returns a **new array** with transformed elements.
  - Used when you want to create a modified version of the array.

- **forEach()**
  - Executes a callback for each element.
  - Returns **undefined**.
  - Used for side effects (e.g., logging, updating values).

- **filter()**
  - Returns a **new array** with elements that pass a condition.
  - Used to filter values from an array.

---

### 💡 Example Code:
```js
let arr = [1, 2, 3];

// map → transforms array
console.log(arr.map(x => x * 2));     
// [2, 4, 6]

// forEach → just iterates
arr.forEach(x => console.log(x));     
// Output: 1 2 3

// filter → selects elements conditionally
console.log(arr.filter(x => x > 1));  
// [2, 3]
```

### [🔝 Back to Top](#core-javascript)

## Question 25: What is Event Delegation?

**Answer:**  
Event Delegation is a technique in JavaScript where you attach a single event listener to a **parent element** instead of adding separate listeners to individual child elements.  
The event propagates (bubbles up) from the child to the parent, and the parent handles it using `event.target`.

---

### ✅ Key Points:
- Improves performance (fewer listeners).
- Useful for dynamically added elements.
- Uses **event bubbling** concept.

---

### 💡 Example Code:
```js
document.getElementById("list").addEventListener("click", function(e) {
  if (e.target.tagName === "LI") {
    console.log("Item clicked:", e.target.innerText);
  }
});
```

### [🔝 Back to Top](#core-javascript)

## Question 26: What is the difference between Function Declaration and Function Expression?

**Answer:**  
- **Function Declaration** → Hoisted to the top of scope, so you can call it before its definition.  
- **Function Expression** → Not hoisted, so you can only call it **after** it's defined.

---

### 💡 Example Code:
```js
// ✅ Function Declaration (hoisted)
console.log(sum(2,3)); // works
function sum(a,b){ return a+b; }

// ❌ Function Expression (not hoisted)
 // console.log(mul(2,3)); // error: mul is not a function
const mul = function(a,b){ return a*b; }
```

### [🔝 Back to Top](#core-javascript)

## Question 27: What are Arrow Functions?

**Answer:**  
Arrow functions provide a shorter syntax for writing functions.  
- They don’t have their own `this`, instead they use lexical `this` from their surrounding scope.  
- Cannot be used as constructors.  

---

### 💡 Example Code:
```js
// Simple arrow function
const add = (a, b) => a + b;
console.log(add(2,3)); // 5

// Lexical 'this'
function Person(name) {
  this.name = name;
  setTimeout(() => {
    console.log("Hi, I am " + this.name);
  }, 1000);
}
new Person("Ritik"); // "Hi, I am Ritik"
```

### [🔝 Back to Top](#core-javascript)

## Question 28: What is the difference between call, apply, and bind?

**Answer:**  
These methods are used to set the value of `this` in a function.

---

### ✅ Key Points:
- **call:** Invokes the function immediately, arguments passed **individually**.  
- **apply:** Invokes the function immediately, arguments passed as an **array**.  
- **bind:** Returns a **new function** with `this` bound (doesn’t call immediately).  

---

### 💡 Example Code:
```js
function greet(msg) {
  console.log(msg + ", " + this.name);
}

const user = { name: "Ritik" };

// call → arguments separately
greet.call(user, "Hello");   // Hello, Ritik

// apply → arguments as array
greet.apply(user, ["Hi"]);   // Hi, Ritik

// bind → returns new function
const bound = greet.bind(user, "Welcome");
bound(); // Welcome, Ritik
```

### [🔝 Back to Top](#core-javascript)

## Question 29: What is `this` in JavaScript?

**Answer:**  
`this` refers to the object that is currently executing the function.  
Its value depends on **how the function is called**.

---

### ✅ Key Points:
- In a **method** → `this` refers to the object calling it.  
- In a **regular function (strict mode)** → `this` is `undefined`.  
- In a **regular function (non-strict)** → `this` is the global object (`window` in browsers).  
- In **arrow functions** → `this` is taken from the **lexical scope** (it does not create its own `this`).  

---

### 💡 Example Code:
```js
const obj = {
  name: "Ritik",
  greet() { console.log("Hello " + this.name); }
};
obj.greet(); // Hello Ritik

function show() {
  console.log(this);
}
show(); // window (in browsers) or undefined (strict mode)

const arrow = () => console.log(this);
arrow(); // lexical this (depends on where arrow function is defined)
```

### [🔝 Back to Top](#core-javascript)

## Question 30: What is the difference between Synchronous and Asynchronous JavaScript?

**Answer:**  
- **Synchronous** → Code runs line by line. Each statement waits for the previous one to finish. (Blocking)  
- **Asynchronous** → Code doesn’t block execution. Tasks can run in the background and complete later. (Non-blocking)

---

### ✅ Key Points:
- JavaScript is **single-threaded**, but uses the **event loop** to handle async operations.  
- Examples of async tasks: `setTimeout`, `fetch`, `Promises`, `async/await`.  

---

### 💡 Example Code:
```js
console.log("Start");

setTimeout(() => console.log("Async Task"), 1000);

console.log("End");

// Output:
// Start
// End
// Async Task (after 1 sec)
```

### [🔝 Back to Top](#core-javascript)

## Question 31: What are Promises?

**Answer:**  
A **Promise** in JavaScript is an object that represents the eventual **completion** (fulfilled) or **failure** (rejected) of an asynchronous operation.

---

### ✅ Key Points:
- States of Promise:  
  1. **Pending** → initial state.  
  2. **Fulfilled** → operation completed successfully.  
  3. **Rejected** → operation failed.  
- Handled using `.then()`, `.catch()`, and `.finally()`.  

---

### 💡 Example Code:
```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("✅ Done!"), 1000);
});

promise
  .then(res => console.log(res))      // ✅ Done!
  .catch(err => console.log(err))     // handles errors
  .finally(() => console.log("Always runs"));
```

### [🔝 Back to Top](#core-javascript)

## Question 32: What is async/await?

**Answer:**  
`async/await` is syntactic sugar over Promises that makes asynchronous code look synchronous and easier to read.

---

### ✅ Key Points:
- `async` → makes a function always return a **Promise**.  
- `await` → pauses execution until the Promise resolves or rejects.  
- Helps avoid **callback hell** and multiple `.then()` chaining.  
- Must be used inside an `async` function.  

---

### 💡 Example Code:
```js
async function fetchData() {
  try {
    let data = await Promise.resolve("Hello 🌍");
    console.log(data); // Hello 🌍
  } catch (error) {
    console.error("Error:", error);
  }
}
fetchData();
```

### [🔝 Back to Top](#core-javascript)

## Question 33: What is the difference between localStorage, sessionStorage, and cookies?

**Answer:**  
These are web storage mechanisms to store data in the browser.

---

### ✅ Key Points:
- **localStorage**
  - Data persists **until explicitly cleared**.  
  - Accessible across **browser tabs**.  
  - Stores **up to ~5MB**.  

- **sessionStorage**
  - Data persists **only until the tab is closed**.  
  - Separate for each **tab/window**.  

- **cookies**
  - Small data sent along with **HTTP requests** to the server.  
  - Limited to **4KB** per cookie.  
  - Can have **expiry dates**.  

---

### 💡 Example Code:
```js
// localStorage
localStorage.setItem("name", "Ritik");
console.log(localStorage.getItem("name")); // Ritik

// sessionStorage
sessionStorage.setItem("role", "dev");
console.log(sessionStorage.getItem("role")); // dev

// Cookies (basic)
document.cookie = "user=Ritik; expires=Fri, 31 Dec 2025 23:59:59 GMT";
console.log(document.cookie);
```

### [🔝 Back to Top](#core-javascript)

## Question 34: What are JavaScript Modules?

**Answer:**  
JavaScript modules allow splitting code into **separate, reusable files**.  
- Each module can **export** variables, functions, or classes.  
- Other files can **import** them to use in their scope.  

---

### ✅ Key Points:
- Promotes **code reusability** and **maintainability**.  
- Supports **named exports** and **default exports**.  
- Works with **ES6 modules** (`import/export`).  

---

### 💡 Example Code:

```js
// math.js (module)
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;

// app.js (main file)
import { add, multiply } from './math.js';

console.log(add(2, 3));      // 5
console.log(multiply(2, 3)); // 6
```

### [🔝 Back to Top](#core-javascript)

## Question 35: What is an IIFE?

**Answer:**  
IIFE stands for **Immediately Invoked Function Expression**.  
It is a function that runs **immediately after it is defined**, without needing to be called separately.

---

### ✅ Key Points:
- Creates a **private scope** to avoid polluting the global namespace.  
- Often used for **initialization code**.  
- Syntax: Wrapped in parentheses `()` and immediately invoked with `()`.

---

### 💡 Example Code:
```js
(function() {
  console.log("IIFE running!");
})();

// Output:
// IIFE running!

// With arrow function
(() => {
  console.log("Arrow IIFE running!");
})();
```

### [🔝 Back to Top](#core-javascript)

## Question 36: What are Higher Order Functions?

**Answer:**  
A **Higher Order Function (HOF)** is a function that either:  
1. Takes one or more functions as **arguments**, or  
2. Returns a **function**.

---

### ✅ Key Points:
- Enables **functional programming**.  
- Examples include `map`, `filter`, `reduce`, and custom HOFs.  
- Useful for **callbacks, composition, and reusable logic**.  

---

### 💡 Example Code:
```js
// Simple HOF example
function greet(name) {
  return "Hello " + name;
}

function process(fn, value) {
  return fn(value);
}

console.log(process(greet, "Ritik")); // Hello Ritik

// Using array methods (HOFs)
const numbers = [1, 2, 3];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6]
```

### [🔝 Back to Top](#core-javascript)

## Question 37: What is the Event Loop in JavaScript?

**Answer:**  
The **Event Loop** is a mechanism that allows JavaScript to handle asynchronous operations.  
It continuously checks the **call stack** and the **callback queue**, pushing functions from the queue to the stack when it's empty.

---

### ✅ Key Points:
- JavaScript is **single-threaded**, but async tasks don’t block execution.  
- **Callbacks, promises, async/await, and timers** are handled via the event loop.  
- Microtasks (Promises) have higher priority than macrotasks (setTimeout, setInterval).  

---

### 💡 Example Code:
```js
console.log("Start");

setTimeout(() => console.log("Callback"), 0);

console.log("End");

// Output:
// Start
// End
// Callback
```

### [🔝 Back to Top](#core-javascript)

## Question 38: What is Debouncing?

**Answer:**  
Debouncing is a technique to **limit the rate** at which a function executes.  
A debounced function runs **only after a specified delay** has passed since the last time it was invoked.  

---

### ✅ Key Points:
- Useful for **scroll, resize, input events** to reduce performance overhead.  
- Prevents a function from being called **too frequently**.  
- Implemented using `setTimeout` and `clearTimeout`.  

---

### 💡 Example Code:
```js
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
}

// Usage
const handleResize = () => console.log("Window resized!");
window.addEventListener("resize", debounce(handleResize, 500));
```

### [🔝 Back to Top](#core-javascript)

## Question 39: What is Throttling?

**Answer:**  
Throttling is a technique to **limit the frequency** at which a function executes.  
A throttled function runs **at most once** in a specified time interval, no matter how many times it is triggered.

---

### ✅ Key Points:
- Useful for **scroll, resize, or mousemove events** to reduce performance overhead.  
- Prevents a function from being called **too often**.  
- Implemented using a **flag** and `setTimeout`.  

---

### 💡 Example Code:
```js
function throttle(fn, limit) {
  let flag = true;
  return function(...args) {
    if (flag) {
      fn(...args);
      flag = false;
      setTimeout(() => flag = true, limit);
    }
  };
}

// Usage
const handleScroll = () => console.log("Scroll event!");
window.addEventListener("scroll", throttle(handleScroll, 1000));
```

### [🔝 Back to Top](#core-javascript)

## Question 40: What is the difference between Deep Copy and Shallow Copy?

**Answer:**  
- **Shallow Copy:** Copies only the **first level** of an object. Nested objects are still referenced.  
- **Deep Copy:** Copies **all levels**, creating a completely independent clone of the object.

---

### ✅ Key Points:
- Shallow copy uses `Object.assign()` or spread operator `{ ...obj }`.  
- Deep copy can use `JSON.parse(JSON.stringify(obj))` or libraries like Lodash (`_.cloneDeep`).  
- Modifying nested objects in shallow copy affects the original object.  

---

### 💡 Example Code:
```js
let obj = { a: 1, b: { c: 2 } };

// Shallow copy
let shallow = { ...obj }; // same memory location 
shallow.b.c = 5;
console.log(obj.b.c); // 5 → nested object still referenced

// Deep copy
let deep = JSON.parse(JSON.stringify(obj)); // mamory location is change
deep.b.c = 10;
console.log(obj.b.c); // 5 → original object unaffected
```

### [🔝 Back to Top](#core-javascript)

## Question 41: What is NaN in JavaScript?

**Answer:**  
`NaN` stands for **Not-a-Number**.  
It represents a value that **cannot be converted to a valid number**.

---

### ✅ Key Points:
- Result of **invalid numeric operations**.  
- `typeof NaN` → `"number"` (special case in JS).  
- Use `isNaN()` or `Number.isNaN()` to check for NaN.  

---

### 💡 Example Code:
```js
console.log(0 / 0);           // NaN
console.log(parseInt("abc"));  // NaN

console.log(typeof NaN);       // "number"

console.log(isNaN("abc"));     // true
console.log(Number.isNaN("abc")); // false (strict check)
```

### [🔝 Back to Top](#core-javascript)

## Question 42: What is `typeof null` in JavaScript?

**Answer:**  
`typeof null` in JavaScript returns `"object"`.  
- This is a **historical bug** in JS, but it has been kept for backward compatibility.

---

### ✅ Key Points:
- `null` represents **intentional absence of any object value**.  
- Despite being a primitive, `typeof null` returns `"object"`.  
- Always use direct checks (`=== null`) instead of `typeof` for null.

---

### 💡 Example Code:
```js
console.log(typeof null); // "object"

// Correct null check
let a = null;
if (a === null) {
  console.log("a is null");
}
```

### [🔝 Back to Top](#core-javascript)

## Question 43: What are Generators?

**Answer:**  
Generators are special functions in JavaScript that can **pause** and **resume** execution using the `yield` keyword.  
- Declared using `function*`.  
- Useful for **iterators, lazy evaluation, and asynchronous workflows**.

---

### ✅ Key Points:
- A generator function returns a **generator object**.  
- Use `next()` to get the **next value**.  
- Can maintain internal state between executions.  

---

### 💡 Example Code:
```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();

console.log(g.next().value); // 1
console.log(g.next().value); // 2
console.log(g.next().value); // 3
console.log(g.next().value); // undefined
```

### [🔝 Back to Top](#core-javascript)

## Question 44: What are Symbols in JavaScript?

**Answer:**  
Symbols are **unique** and **immutable** primitive values.  
- Often used as **object property keys** to avoid name collisions.

---

### ✅ Key Points:
- Every `Symbol()` is **unique**, even with the same description.  
- Cannot be accessed via normal enumeration (`for...in`) unless using `Object.getOwnPropertySymbols()`.  
- Useful for defining **hidden or private object properties**.  

---

### 💡 Example Code:
```js
const sym = Symbol("id");

const obj = {
  [sym]: 123
};

console.log(obj[sym]); // 123

// Symbols are unique
const sym2 = Symbol("id");
console.log(sym === sym2); // false
```

### [🔝 Back to Top](#core-javascript)

## Question 45: What is Object Destructuring?

**Answer:**  
Object destructuring allows you to **extract values** from objects (or arrays) into separate variables.

---

### ✅ Key Points:
- Simplifies assignment of multiple properties.  
- Works with **objects** and **arrays**.  
- Can use **default values** and **renaming**.  

---

### 💡 Example Code:
```js
const user = { name: "Ritik", age: 24 };

// Basic destructuring
const { name, age } = user;
console.log(name); // Ritik
console.log(age);  // 24

// Renaming and default value
const { name: username, gender = "male" } = user;
console.log(username); // Ritik
console.log(gender);   // male
```

### [🔝 Back to Top](#core-javascript)

## Question 46: What is the Spread Operator?

**Answer:**  
The **spread operator (`...`)** allows an iterable (like an array or object) to be **expanded** into individual elements.

---

### ✅ Key Points:
- Used to **copy arrays/objects**.  
- Can merge arrays or objects easily.  
- Works with **function arguments**.  

---

### 💡 Example Code:
```js
// Array spread
const arr = [1, 2, 3];
const copy = [...arr];
console.log(copy); // [1, 2, 3]

// Merging arrays
const arr2 = [4, 5];
const merged = [...arr, ...arr2];
console.log(merged); // [1, 2, 3, 4, 5]

// Object spread
const obj = { a: 1, b: 2 };
const newObj = { ...obj, c: 3 };
console.log(newObj); // { a: 1, b: 2, c: 3 }
```

### [🔝 Back to Top](#core-javascript)

## Question 47: What is the Rest Operator?

**Answer:**  
The **rest operator (`...`)** collects **multiple function arguments** into a single array.

---

### ✅ Key Points:
- Used in **function parameters** to handle variable number of arguments.  
- Must be **last parameter** in the function definition.  
- Different from the **spread operator**, which expands an iterable.  

---

### 💡 Example Code:
```js
function sum(...nums) {
  return nums.reduce((a, b) => a + b, 0);
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(4, 5, 6, 7)); // 22

// Using with array destructuring
const [first, ...rest] = [10, 20, 30, 40];
console.log(first); // 10
console.log(rest);  // [20, 30, 40]
```

### [🔝 Back to Top](#core-javascript)

## Question 48: What is Memoization?

**Answer:**  
Memoization is a **performance optimization technique** where the results of expensive function calls are **cached** so that subsequent calls with the same arguments return the cached result.

---

### ✅ Key Points:
- Reduces **repeated computations**.  
- Useful in **recursive functions** like Fibonacci or heavy calculations.  
- Implemented using objects, Maps, or WeakMaps for caching.  

---

### 💡 Example Code:
```js
function memoize(fn) {
  const cache = {};
  return function(x) {
    if (cache[x]) return cache[x];
    cache[x] = fn(x);
    return cache[x];
  };
}

// Example usage
function square(n) {
  console.log("Calculating...");
  return n * n;
}

const memoizedSquare = memoize(square);

console.log(memoizedSquare(5)); // Calculating... 25
console.log(memoizedSquare(5)); // 25 (cached, no calculation)
```

### [🔝 Back to Top](#core-javascript)

## Question 49: What is Currying?

**Answer:**  
Currying is a technique of transforming a function that takes **multiple arguments** into a sequence of **unary (single-argument) functions**.

---

### ✅ Key Points:
- Each function returns another function until all arguments are provided.  
- Useful for **partial application** and **function composition**.  
- Enhances **code reusability** and readability.  

---

### 💡 Example Code:
```js
function curry(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

console.log(curry(1)(2)(3)); // 6

// Partial application
const add1 = curry(1);
const add1and2 = add1(2);
console.log(add1and2(3)); // 6
```

### [🔝 Back to Top](#core-javascript)

## Question 50: What are Polyfills?

**Answer:**  
A **polyfill** is a piece of code (usually JavaScript) that **adds support** for features that are **not available in older browsers**.

---

### ✅ Key Points:
- Ensures **cross-browser compatibility**.  
- Commonly used for **ES6+ features** like `Array.prototype.includes`, `Promise`, `fetch`, etc.  
- Helps **modern code run on legacy environments**.

---

### 💡 Example Code:
```js
// Polyfill for Array.prototype.includes
if (!Array.prototype.includes) {
  Array.prototype.includes = function(element) {
    return this.indexOf(element) !== -1;
  };
}

// Usage
const arr = [1, 2, 3];
console.log(arr.includes(2)); // true
```

### [🔝 Back to Top](#core-javascript)

## Question 51: What is a Generator Function?

**Answer:**  
A **generator function** is a special type of function that can **pause** and **resume** execution using the `yield` keyword.  
- Declared with `function*`.  
- Returns an **iterator object**.

---

### ✅ Key Points:
- Can maintain **internal state** between executions.  
- Useful for **lazy evaluation, iterators, and async workflows**.  
- Use `next()` to retrieve values one by one.

---

### 💡 Example Code:
```js
function* numberGen() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGen();

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
console.log(gen.next().value); // undefined
```

### [🔝 Back to Top](#core-javascript)

## Question 52: What is the difference between for...in and for...of loops?

**Answer:**  
- **for...in** → iterates over the **keys/properties** of an object (or array indices).  
- **for...of** → iterates over the **values** of an iterable (array, string, Map, Set, etc.).

---

### ✅ Key Points:
- Use **for...in** for objects and **for...of** for arrays or iterables.  
- **for...in** returns **keys/indexes**, not values.  
- **for...of** cannot be used directly on plain objects (use `Object.values()` or `Object.entries()`).

---

### 💡 Example Code:
```js
const arr = [10, 20, 30];

// for...in iterates over indexes
for (let index in arr) {
  console.log(index); // 0 1 2
}

// for...of iterates over values
for (let value of arr) {
  console.log(value); // 10 20 30
}

// Object example
const obj = { a: 1, b: 2 };
for (let key in obj) {
  console.log(key, obj[key]); // a 1, b 2
}
```

### [🔝 Back to Top](#core-javascript)

## Question 53: What is the difference between Object.freeze() and Object.seal()?

**Answer:**  
- **Object.freeze()** → Prevents **adding, deleting, or modifying** any properties.  
- **Object.seal()** → Prevents **adding or deleting** properties, but **modification of existing properties is allowed**.

---

### ✅ Key Points:
- Both methods **freeze the object structure** to some extent.  
- Use `Object.freeze()` for complete immutability.  
- Use `Object.seal()` to allow value updates but restrict structure changes.

---

### 💡 Example Code:
```js
const obj = { name: "Ritik" };

// Object.freeze
Object.freeze(obj);
obj.name = "Patidar"; // ignored
console.log(obj.name); // Ritik

// Object.seal
const obj2 = { name: "Ritik" };
Object.seal(obj2);
obj2.name = "Patidar"; // works
console.log(obj2.name); // Patidar
```

### [🔝 Back to Top](#core-javascript)

## Question 54: What is the difference between setTimeout and setInterval?

**Answer:**  
- **setTimeout** → Executes a function **once** after a specified delay.  
- **setInterval** → Executes a function **repeatedly** at specified intervals.

---

### ✅ Key Points:
- `setTimeout` is used for **delayed execution**.  
- `setInterval` is used for **periodic tasks**.  
- Both return an **ID** that can be cleared using `clearTimeout` or `clearInterval`.

---

### 💡 Example Code:
```js
// Executes once after 1 second
setTimeout(() => console.log("Executed once"), 1000);

// Executes every 1 second
const intervalId = setInterval(() => console.log("Executed repeatedly"), 1000);

// Stop the interval after 5 seconds
setTimeout(() => clearInterval(intervalId), 5000);
```

### [🔝 Back to Top](#core-javascript)

## Question 55: What is the difference between ==, ===, !=, and !==?

**Answer:**  
- **==** → Equality with **type coercion** (loose equality).  
- **===** → **Strict equality**, no type coercion.  
- **!=** → Inequality with **type coercion**.  
- **!==** → **Strict inequality**, no type coercion.

---

### ✅ Key Points:
- Always prefer `===` and `!==` for **accurate comparisons**.  
- `==` and `!=` can lead to **unexpected results** due to type coercion.

---

### 💡 Example Code:
```js
console.log(5 == "5");   // true  (type coercion)
console.log(5 === "5");  // false (different types)

console.log(5 != "5");   // false (type coercion)
console.log(5 !== "5");  // true  (strict inequality)
```

### [🔝 Back to Top](#core-javascript)

## Question 56: What is the difference between document.querySelector and document.getElementById?

**Answer:**  
- **getElementById** → Selects an element **only by its ID**.  
- **querySelector** → Selects **any CSS selector** (ID, class, tag, etc.) and returns the **first match**.

---

### ✅ Key Points:
- `getElementById` is **faster** but limited to IDs.  
- `querySelector` is **more flexible** and supports **complex selectors**.  
- Use `querySelectorAll` to get **all matching elements**.

---

### 💡 Example Code:
```js
const el1 = document.getElementById("myDiv");
console.log(el1);

const el2 = document.querySelector("#myDiv"); // same as getElementById
console.log(el2);

const firstBtn = document.querySelector(".btn"); // selects first element with class 'btn'
const allBtns = document.querySelectorAll(".btn"); // selects all elements with class 'btn'
```

### [🔝 Back to Top](#core-javascript)

## Question 57: What is the difference between innerHTML and textContent?

**Answer:**  
- **innerHTML** → Returns the **HTML content** of an element as a string (including tags).  
- **textContent** → Returns **only the text content**, ignoring HTML tags.

---

### ✅ Key Points:
- Use `innerHTML` when you need to **read or set HTML structure**.  
- Use `textContent` for **plain text** to avoid XSS vulnerabilities.  
- `textContent` is **faster** and safer for text-only updates.

---

### 💡 Example Code:
```js
const div = document.createElement("div");

div.innerHTML = "<b>Hello</b>";
console.log(div.innerHTML);   // <b>Hello</b>
console.log(div.textContent); // Hello

// Updating content
div.textContent = "Hi there!";
console.log(div.innerHTML);   // Hi there!
```

### [🔝 Back to Top](#core-javascript)

## Question 58: What is the difference between == null and === null?

**Answer:**  
- **== null** → Returns `true` for **null or undefined** (loose equality).  
- **=== null** → Returns `true` **only for null** (strict equality).

---

### ✅ Key Points:
- `== null` is a common shortcut to check for **both null and undefined**.  
- `=== null` ensures **strict type check**.  
- Prefer `===` for **accurate comparisons**.

---

### 💡 Example Code:
```js
console.log(null == undefined);  // true
console.log(null === undefined); // false
console.log(null === null);      // true

// Practical use
let value;
if (value == null) {
  console.log("Value is null or undefined");
}
```

### [🔝 Back to Top](#core-javascript)

## Question 59: What is the difference between Call Stack and Task Queue?

**Answer:**  
- **Call Stack** → Stores **synchronous function calls**.  
- **Task Queue** → Stores **asynchronous callbacks** (e.g., `setTimeout`, Promises).  
- The **event loop** moves tasks from the queue to the stack when the stack is empty.

---

### ✅ Key Points:
- JavaScript is **single-threaded**; synchronous code blocks the stack.  
- Asynchronous operations wait in the **task queue**.  
- Event loop ensures **non-blocking execution**.

---

### 💡 Example Code:
```js
console.log("Start");

setTimeout(() => console.log("Async"), 0);

console.log("End");

// Output:
// Start
// End
// Async
```

### [🔝 Back to Top](#core-javascript)

## Question 60: What is the difference between null, undefined, and NaN?

**Answer:**  
- **null** → Explicitly assigned to indicate **no value**.  
- **undefined** → Variable is **declared but not assigned** a value.  
- **NaN** → Stands for **Not-a-Number**, result of invalid numeric operations.

---

### ✅ Key Points:
- `null` is **intentional**, `undefined` is **default/uninitialized**.  
- `NaN` is of type `number` (`typeof NaN === "number"`).  
- Useful for **type and value checks**.

---

### 💡 Example Code:
```js
let a;
console.log(a); // undefined

let b = null;
console.log(b); // null

console.log(0 / 0); // NaN
console.log(typeof NaN); // "number"
```

### [🔝 Back to Top](#core-javascript)

## Question 61: What is the difference between Object.keys, Object.values, and Object.entries?

**Answer:**  
- **Object.keys(obj)** → Returns an **array of keys** of the object.  
- **Object.values(obj)** → Returns an **array of values** of the object.  
- **Object.entries(obj)** → Returns an **array of [key, value] pairs** of the object.

---

### ✅ Key Points:
- Useful for **iterating over objects**.  
- Can be combined with `for...of` or array methods like `map`, `filter`.  
- `Object.entries` is handy for **destructuring in loops**.

---

### 💡 Example Code:
```js
const obj = { a: 1, b: 2 };

console.log(Object.keys(obj));    // ['a', 'b']
console.log(Object.values(obj));  // [1, 2]
console.log(Object.entries(obj)); // [['a', 1], ['b', 2]]

// Example: iterating using entries
for (const [key, value] of Object.entries(obj)) {
  console.log(key, value); // a 1, b 2
}
```

### [🔝 Back to Top](#core-javascript)

## Question 62: What is the difference between undefined and undeclared?

**Answer:**  
- **undefined** → A variable is **declared but not assigned** a value.  
- **undeclared** → A variable is **not declared** in the scope at all.

---

### ✅ Key Points:
- Accessing an **undefined** variable returns `undefined`.  
- Accessing an **undeclared** variable throws a `ReferenceError`.  
- Use `let`, `const`, or `var` to **declare variables** before use.

---

### 💡 Example Code:
```js
let a;
console.log(a); // undefined

// console.log(b); // ReferenceError: b is not defined
```

### [🔝 Back to Top](#core-javascript)

## Question 63: What is Event Bubbling in JavaScript?

**Answer:**  
Event bubbling is the process where an event **starts from the target element** and **bubbles up** to its ancestor elements in the DOM tree.

---

### ✅ Key Points:
- Default behavior in JavaScript events.  
- Useful for **event delegation**.  
- Can be stopped using `event.stopPropagation()`.

---

### 💡 Example Code:
```html
<div id="parent">
  <button id="child">Click Me</button>
</div>
document.getElementById("child").addEventListener("click", () => {
  console.log("Child clicked");
});

document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent clicked");
});

// Clicking the child logs:
// "Child clicked"
// "Parent clicked"
```

### [🔝 Back to Top](#core-javascript)

## Question 64: What is Event Capturing in JavaScript?

**Answer:**  
Event capturing is the opposite of bubbling. The event **starts from the root element** and **travels down** to the target element.

---

### ✅ Key Points:
- Set the third parameter of `addEventListener` to `true` to enable capturing.  
- Useful when you want the parent element to **handle events before children**.  
- Can be combined with **bubbling** for flexible event handling.

---

### 💡 Example Code:
```html
<div id="parent">
  <button id="child">Click Me</button>
</div>
document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent clicked");
}, true);

document.getElementById("child").addEventListener("click", () => {
  console.log("Child clicked");
}, true);

// Clicking the child logs:
// "Parent clicked"
// "Child clicked"
```

### [🔝 Back to Top](#core-javascript)

## Question 65: What is the difference between filter and find?

**Answer:**  
- **filter** → Returns **all elements** that satisfy the condition.  
- **find** → Returns **the first element** that satisfies the condition.

---

### ✅ Key Points:
- `filter` always returns an **array** (can be empty).  
- `find` returns a **single element** or `undefined`.  
- Useful for searching/filtering arrays based on conditions.

---

### 💡 Example Code:
```js
const arr = [5, 10, 15];

console.log(arr.filter(x => x > 5)); // [10, 15]
console.log(arr.find(x => x > 5));   // 10

// Using find with objects
const users = [{id:1,name:"Ritik"},{id:2,name:"Patidar"}];
console.log(users.find(u => u.id === 2)); // {id:2, name:"Patidar"}
```

### [🔝 Back to Top](#core-javascript)

## Question 66: What is the difference between slice and splice?

**Answer:**  
- **slice** → Returns a **new array**, does **not modify** the original array.  
- **splice** → **Modifies the original array**, can **add or remove elements**.

---

### ✅ Key Points:
- `slice(start, end)` → extracts a **portion** of the array (end not included).  
- `splice(start, deleteCount, ...items)` → **removes and/or adds** elements at specified index.  
- Use `slice` for **non-destructive copying**, `splice` for **in-place changes**.

---

### 💡 Example Code:
```js
const arr = [1, 2, 3, 4];

// slice → does not change original
console.log(arr.slice(1, 3)); // [2, 3]
console.log(arr);             // [1, 2, 3, 4]

// splice → modifies original
arr.splice(1, 2); // remove 2 elements from index 1
console.log(arr); // [1, 4]

// splice → adding elements
arr.splice(1, 0, 5, 6); 
console.log(arr); // [1, 5, 6, 4]
```

### [🔝 Back to Top](#core-javascript)

## Question 67: What is the difference between default and named exports?

**Answer:**  
- **Default Export** → Only **one default export** per module.  
- **Named Export** → Multiple exports allowed, must import using `{}`.

---

### ✅ Key Points:
- Default export is imported **without curly braces**.  
- Named exports are imported **with curly braces**.  
- Modules can have **both default and named exports** simultaneously.

---

### 💡 Example Code:
// module.js
```js
export default function greet() { 
  console.log("Hello"); 
}

export const name = "Ritik";
```
// main.js
```js
import greet from "./module.js";      // default import
import { name } from "./module.js";   // named import

greet();          // Hello
console.log(name); // Ritik
```

### [🔝 Back to Top](#core-javascript)

## Question 68: What is the difference between process.nextTick() and setImmediate() in Node.js?

**Answer:**  
- **process.nextTick()** → Executes **before the next event loop tick**.  
- **setImmediate()** → Executes **after I/O events** in the next event loop cycle.

---

### ✅ Key Points:
- `process.nextTick()` has **higher priority** than `setImmediate()`.  
- Both are used to **schedule callbacks** asynchronously in Node.js.  
- Useful for **deferring execution** without blocking the main thread.

---

### 💡 Example Code:
```js
process.nextTick(() => console.log("NextTick"));
setImmediate(() => console.log("Immediate"));

// Output:
// NextTick
// Immediate
```

### [🔝 Back to Top](#core-javascript)

## Question 69: What is the difference between == and Object.is()?

**Answer:**  
- **==** → Performs **type coercion** before comparison.  
- **Object.is()** → Performs **strict equality**, similar to `===`, but handles **NaN** and **-0/+0** differently.

---

### ✅ Key Points:
- Use `Object.is()` for **more precise equality checks**.  
- `===` and `Object.is()` are similar except for **NaN and signed zero**.

---

### 💡 Example Code:
```js
console.log(NaN === NaN);         // false
console.log(Object.is(NaN, NaN)); // true

console.log(+0 === -0);           // true
console.log(Object.is(+0, -0));   // false

console.log(5 == "5");            // true (type coercion)
console.log(5 === "5");           // false
```

### [🔝 Back to Top](#core-javascript)

## Question 70: What is the difference between null and 0 in JavaScript?

**Answer:**  
- **null** → Represents **no value** or empty.  
- **0** → Represents **numeric zero**.

---

### ✅ Key Points:
- `null` is **falsy**, but not equal to `0` with `==`.  
- Use `===` for strict comparison to avoid unexpected type coercion.  
- `0` is a **number**, while `null` is an **object type** (historical quirk).

---

### 💡 Example Code:
```js
console.log(null == 0);  // false
console.log(null === 0); // false
console.log(0 == false); // true
console.log(0 === false);// false
```

### [🔝 Back to Top](#core-javascript)

## Question 71: What is the difference between `var obj1 = {a:1}` and `var obj2 = Object.create(null)`?

**Answer:**  
- **obj1** → Inherits from **`Object.prototype`**, so has default methods like `toString()`.  
- **obj2** → Does **not inherit any prototype**, so no built-in object methods.

---

### ✅ Key Points:
- `Object.create(null)` creates a **pure object** with no prototype.  
- Useful when you want a **clean dictionary/map** without prototype interference.  
- `obj1` can access methods like `toString`, `hasOwnProperty`.  
- `obj2` cannot access these methods directly.

---

### 💡 Example Code:
```js
const obj1 = { a: 1 };
console.log(obj1.toString()); // [object Object]

const obj2 = Object.create(null);
console.log(obj2.toString);   // undefined
```

### [🔝 Back to Top](#core-javascript)

## Question 72: What is the difference between for..in and Object.keys()?

**Answer:**  
- **for..in** → Iterates over **all enumerable properties**, including inherited ones from the prototype chain.  
- **Object.keys()** → Returns **only the object's own property names**, ignoring the prototype chain.

---

### ✅ Key Points:
- Use `for..in` when you want to traverse **all enumerable properties**.  
- Use `Object.keys()` when you need **only direct properties**.  
- `Object.keys()` returns an **array**, which can be used with `forEach` or `map`.

---

### 💡 Example Code:
```js
const obj = { a: 1 };
Object.prototype.b = 2; // inherited property

for (let key in obj) {
  console.log(key); // a, b
}

console.log(Object.keys(obj)); // ["a"]
```

### [🔝 Back to Top](#core-javascript)

## Question 73: What is the difference between isNaN() and Number.isNaN()?

**Answer:**  
- **isNaN()** → Converts the value to a number first, then checks if it is `NaN`.  
- **Number.isNaN()** → Strictly checks if the value is `NaN` **without type coercion**.

---

### ✅ Key Points:
- `isNaN()` may return **true for non-numeric strings**.  
- `Number.isNaN()` is **safer** for checking actual `NaN` values.  

---

### 💡 Example Code:
```js
console.log(isNaN("hello"));        // true (string converted to NaN)
console.log(Number.isNaN("hello")); // false (no type coercion)
console.log(Number.isNaN(NaN));     // true
console.log(isNaN(NaN));            // true
```

### [🔝 Back to Top](#core-javascript)

## Question 74: What is the difference between setTimeout(fn, 0) and Promise.resolve().then(fn)?

**Answer:**  
- **setTimeout(fn, 0)** → Schedules a **macrotask**, executes after the current call stack and all microtasks.  
- **Promise.resolve().then(fn)** → Schedules a **microtask**, executes **before macrotasks** in the event loop.

---

### ✅ Key Points:
- Microtasks have **higher priority** than macrotasks.  
- Use Promises to run code **immediately after current execution**, before `setTimeout`.  
- Helps in understanding **JavaScript’s event loop** and execution order.

---

### 💡 Example Code:
```js
setTimeout(() => console.log("timeout"), 0);       // macrotask
Promise.resolve().then(() => console.log("promise")); // microtask
console.log("sync");                                // synchronous

// Output:
// sync
// promise
// timeout
```

### [🔝 Back to Top](#core-javascript)

## Question 75: What is the difference between typeof and instanceof?

**Answer:**  
- **typeof** → Returns the **type of a variable** as a string (`"string"`, `"number"`, `"object"`, `"function"`, etc.).  
- **instanceof** → Checks if an object **inherits from a specific constructor**.

---

### ✅ Key Points:
- `typeof` is useful for **primitive types**.  
- `instanceof` is useful for **objects and class instances**.  
- Arrays, functions, and objects can be distinguished using `instanceof`.

---

### 💡 Example Code:
```js
console.log(typeof 5);             // "number"
console.log(typeof "hello");       // "string"
console.log(typeof {});            // "object"
console.log(typeof function(){});  // "function"

console.log([] instanceof Array);  // true
console.log({} instanceof Object); // true
console.log([] instanceof Object); // true
```

### [🔝 Back to Top](#core-javascript)

## Question 76: What is the difference between hasOwnProperty and in operator?

**Answer:**  
- **hasOwnProperty** → Checks if the property exists **only on the object itself**.  
- **in** → Checks if the property exists **on the object or its prototype chain**.

---

### ✅ Key Points:
- Use `hasOwnProperty` to avoid **prototype-inherited properties**.  
- `in` is useful when you want to check **all properties**, including inherited ones.

---

### 💡 Example Code:
```js
const obj = { a: 1 };

console.log(obj.hasOwnProperty('a')); // true
console.log('a' in obj);              // true
console.log('toString' in obj);       // true (inherited from Object.prototype)
```

### [🔝 Back to Top](#core-javascript)

## Question 77: What is the difference between Object.freeze() and Object.preventExtensions()?

**Answer:**  
- **Object.freeze()** → Prevents **adding, deleting, or modifying** properties.  
- **Object.preventExtensions()** → Prevents **adding new properties**, but allows **modifying or deleting** existing ones.

---

### ✅ Key Points:
- `Object.freeze()` → fully immutable object.  
- `Object.preventExtensions()` → partially immutable (cannot grow object).  
- Useful for **protecting objects** in different levels.

---

### 💡 Example Code:
```js
const obj = { a: 1 };

Object.preventExtensions(obj);
obj.b = 2;    // ignored
obj.a = 3;    // works
delete obj.a; // works
console.log(obj); // { a: 3 }
```

### [🔝 Back to Top](#core-javascript)

## Question 78: What is the difference between forEach, map, and reduce?

**Answer:**  
- **forEach** → Iterates over elements, **does not return** anything (`undefined`).  
- **map** → Iterates and returns a **new array** with transformed elements.  
- **reduce** → Iterates and returns a **single accumulated value**.

---

### ✅ Key Points:
- Use `forEach` for **side effects** (logging, updating external variables).  
- Use `map` when you want a **new array** from existing data.  
- Use `reduce` for **aggregation** (sum, product, concatenation).

---

### 💡 Example Code:
```js
const arr = [1, 2, 3];

// forEach → no return
arr.forEach(x => console.log(x)); // 1 2 3

// map → returns new array
const doubled = arr.map(x => x * 2);
console.log(doubled); // [2, 4, 6]

// reduce → returns single value
const sum = arr.reduce((a, b) => a + b, 0);
console.log(sum); // 6
```

### [🔝 Back to Top](#core-javascript)

## Question 79: What is the difference between call stack and event loop?

**Answer:**  
- **Call Stack** → Stores **synchronous function calls** and executes them in order (LIFO).  
- **Event Loop** → Monitors the call stack and task queues, and **pushes asynchronous callbacks** (macrotasks/microtasks) to the stack when it’s empty.

---

### ✅ Key Points:
- JavaScript is **single-threaded**.  
- Event loop enables **non-blocking async behavior** using callbacks, promises, and timers.  
- Understanding this is **key for async programming** in JS.

---

### 💡 Example Code:
```js
console.log("Start");

setTimeout(() => console.log("Async"), 0);

console.log("End");

// Output:
// Start
// End
// Async
```

### [🔝 Back to Top](#core-javascript)

## Question 80: What is the difference between deep equality and shallow equality?

**Answer:**  
- **Shallow equality** → Compares **top-level values only**; nested objects/arrays are compared by reference.  
- **Deep equality** → Compares **all nested values recursively**, checking actual content.

---

### ✅ Key Points:
- Shallow equality works well for **primitive values**.  
- Deep equality is needed for **nested objects or arrays**.  
- Can be implemented using recursion or libraries like **Lodash** (`_.isEqual`).

---

### 💡 Example Code:
```js
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };

// Shallow comparison
console.log(obj1.b === obj2.b); // false

// Deep comparison (manual)
function deepEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}
console.log(deepEqual(obj1, obj2)); // true
```

### [🔝 Back to Top](#core-javascript)

## Question 81: What is the difference between for..of and forEach?

**Answer:**  
- **for..of** → Loops over **iterable values** (arrays, strings, maps, sets), and supports **break/continue**.  
- **forEach** → Executes a **callback for each element**, does **not support break/continue**.

---

### ✅ Key Points:
- Use `for..of` when you need **loop control** or async/await inside loops.  
- Use `forEach` for **simple iteration** without breaking.

---

### 💡 Example Code:
```js
const arr = [1, 2, 3];

// for..of → supports break
for (let x of arr) {
  if (x === 2) break;
  console.log(x); // 1
}

// forEach → cannot break
arr.forEach(x => console.log(x)); // 1 2 3
```

### [🔝 Back to Top](#core-javascript)

## Question 82: What is the difference between Object.create(null) and {}

**Answer:**  
- **{}** → Creates a normal object that **inherits from `Object.prototype`**, so it has built-in methods like `toString()`, `hasOwnProperty()`, etc.  
- **Object.create(null)** → Creates a **pure object with no prototype**, so it does **not inherit any methods**.

---

### ✅ Key Points:
- Use `Object.create(null)` when you want a **dictionary-like object** without prototype interference.  
- Regular `{}` is fine for most general purposes.

---

### 💡 Example Code:
```js
const obj1 = {};
console.log(obj1.toString()); // [object Object]

const obj2 = Object.create(null);
console.log(obj2.toString);   // undefined
```

### [🔝 Back to Top](#core-javascript)

## Question 83: What is the difference between JSON.stringify and JSON.parse?

**Answer:**  
- **JSON.stringify** → Converts a **JavaScript object to a JSON string**.  
- **JSON.parse** → Converts a **JSON string back to a JavaScript object**.

---

### ✅ Key Points:
- Useful for **data storage, API communication, and localStorage**.  
- Be careful: `JSON.parse` will throw an error for **invalid JSON strings**.

---

### 💡 Example Code:
```js
const obj = { a: 1 };

// Object → String
const str = JSON.stringify(obj);
console.log(str); // '{"a":1}'

// String → Object
const parsed = JSON.parse(str);
console.log(parsed); // { a: 1 }
```

### [🔝 Back to Top](#core-javascript)

## Question 84: What is the difference between null and NaN?

**Answer:**  
- **null** → Represents **intentional absence of value**.  
- **NaN** → Stands for **Not-a-Number**, represents an **invalid or unrepresentable number**.

---

### ✅ Key Points:
- `typeof null` → `"object"` (historical JS quirk)  
- `typeof NaN` → `"number"`  
- `null` behaves as 0 in arithmetic operations, while `NaN` propagates errors.

---

### 💡 Example Code:
```js
console.log(null + 1);  // 1
console.log(NaN + 1);   // NaN
console.log(typeof null); // "object"
console.log(typeof NaN);  // "number"
```

### [🔝 Back to Top](#core-javascript)

## Question 85: What is the difference between Object.assign() and spread operator {...obj}?

**Answer:**  
- Both create a **shallow copy** of an object.  
- **Object.assign()** → Can **merge multiple objects** into a target object.  
- **Spread operator {...obj}** → Simpler syntax for copying or merging objects.

---

### ✅ Key Points:
- Both do **not perform deep cloning**; nested objects are still referenced.  
- Use `Object.assign()` if you need to **merge multiple sources** dynamically.

---

### 💡 Example Code:
```js
const obj1 = { a: 1 };
const obj2 = { b: 2 };

// Using Object.assign
const merged = Object.assign({}, obj1, obj2);

// Using spread operator
const spreadMerged = { ...obj1, ...obj2 };

console.log(merged);       // { a:1, b:2 }
console.log(spreadMerged); // { a:1, b:2 }
```

### [🔝 Back to Top](#core-javascript)

## Question 86: What is the difference between Array.from() and Array.of()?

**Answer:**  
- **Array.from()** → Converts **array-like or iterable objects** (like strings, NodeList) into an array.  
- **Array.of()** → Creates a new array from the **passed arguments**.

---

### ✅ Key Points:
- `Array.from()` is useful for **converting non-array objects**.  
- `Array.of()` ensures that a **single numeric argument** becomes an array element, not the array length.

---

### 💡 Example Code:
```js
// Array.from
console.log(Array.from('hello')); // ['h','e','l','l','o']

// Array.of
console.log(Array.of(5));       // [5]
console.log(Array.of(1,2,3));   // [1,2,3]
```

### [🔝 Back to Top](#core-javascript)

## Question 87: What is the difference between window.onload and DOMContentLoaded?

**Answer:**  
- **window.onload** → Fires when the **entire page** including images, styles, and scripts is fully loaded.  
- **DOMContentLoaded** → Fires when the **DOM is fully constructed**, before loading images and styles.

---

### ✅ Key Points:
- Use `DOMContentLoaded` for faster script execution that depends on DOM elements.  
- Use `window.onload` if your code depends on **all resources being fully loaded**.

---

### 💡 Example Code:
```js
// DOMContentLoaded
document.addEventListener("DOMContentLoaded", () => console.log("DOM ready"));

// window.onload
window.onload = () => console.log("All resources loaded");
```

### [🔝 Back to Top](#core-javascript)

## Question 88: What is the difference between flatMap() and map()?

**Answer:**  
- **map()** → Transforms each element and returns a **new array** (nested arrays possible).  
- **flatMap()** → Maps each element and **flattens** the result by **one level**.

---

### ✅ Key Points:
- `flatMap()` = `map()` + `flat(1)`.  
- Useful for **flattening arrays after transformation** in one step.

---

### 💡 Example Code:
```js
const arr = [1,2,3];

// Using map
console.log(arr.map(x => [x*2]));    // [[2],[4],[6]]

// Using flatMap
console.log(arr.flatMap(x => [x*2])); // [2,4,6]
```

### [🔝 Back to Top](#core-javascript)

## Question 89: What is the difference between WeakMap and Map in JavaScript?

**Answer:**  
- **Map** → Stores **strong references**, keys can be **any type**, prevents garbage collection as long as the Map exists.  
- **WeakMap** → Keys must be **objects only**, allows garbage collection if no other reference exists.

---

### ✅ Key Points:
- WeakMap is useful for **private data storage** associated with objects.  
- WeakMap **cannot be iterated** (no size property, no forEach).  
- Map is fully iterable and supports any key type.

---

### 💡 Example Code:
```js
// Map
const map = new Map();
const obj = {a:1};
map.set(obj, "value");
console.log(map.get(obj)); // value

// WeakMap
const weakMap = new WeakMap();
weakMap.set(obj, "value");
console.log(weakMap.get(obj)); // value
```

### [🔝 Back to Top](#core-javascript)

## Question 90: What is the difference between WeakSet and Set?

**Answer:**  
- **Set** → Stores **unique values** of any type, prevents duplicates.  
- **WeakSet** → Stores **objects only**, allows garbage collection if no other reference exists.

---

### ✅ Key Points:
- WeakSet **cannot be iterated**, no size property.  
- Set supports iteration and any data type.  
- WeakSet is useful for **tracking objects without preventing GC**.

---

### 💡 Example Code:
```js
// Set
const set = new Set();
set.add(1);
set.add(1);
console.log(set); // Set {1}

// WeakSet
const weakSet = new WeakSet();
const obj = {a:1};
weakSet.add(obj);
console.log(weakSet.has(obj)); // true
```

### [🔝 Back to Top](#core-javascript)

## Question 91: What is the difference between structuredClone() and JSON.parse(JSON.stringify())?

**Answer:**  
- **structuredClone()** → Deep clones **all types**, including Date, Map, Set, circular references.  
- **JSON.parse(JSON.stringify())** → Deep clones **only JSON-serializable objects**, loses Date, functions, undefined, etc.

---

### ✅ Key Points:
- structuredClone is safer for **complex objects**.  
- JSON approach can **break Dates, functions, undefined, and circular references**.  

---

### 💡 Example Code:
```js
const obj = { a: new Date(), b: 1 };

// Using structuredClone
const clone = structuredClone(obj);
console.log(clone.a instanceof Date); // true

// Using JSON
const jsonClone = JSON.parse(JSON.stringify(obj));
console.log(jsonClone.a instanceof Date); // false
```

### [🔝 Back to Top](#core-javascript)

## Question 92: What is the difference between Event Delegation and Direct Event Handling?

**Answer:**  
- **Event Delegation** → Attach a listener to a **parent element**, which handles events from its child elements. Saves memory and works for dynamically added elements.  
- **Direct Event Handling** → Attach a listener to **each element individually**. Can consume more memory and won’t handle future dynamically added elements automatically.

---

### 💡 Example Code:
```js
// Event Delegation
document.getElementById("parent").addEventListener("click", e => {
  if(e.target.tagName === "BUTTON") console.log("Button clicked");
});

// Direct Event Handling
document.getElementById("btn1").addEventListener("click", () => console.log("Button 1 clicked"));
document.getElementById("btn2").addEventListener("click", () => console.log("Button 2 clicked"));
```

### [🔝 Back to Top](#core-javascript)

## Question 93: What is the difference between Promise.all and Promise.race?

**Answer:**  
- **Promise.all()** → Waits for **all promises** to resolve. Rejects immediately if **any promise rejects**.  
- **Promise.race()** → Resolves or rejects as soon as **the first promise settles** (either resolves or rejects).

---

### 💡 Example Code:
```js
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);

// Waits for both to resolve
Promise.all([p1, p2]).then(console.log); // [1, 2]

// Resolves as soon as first settles
Promise.race([p1, p2]).then(console.log); // 1
```

### [🔝 Back to Top](#core-javascript)

## Question 94: What is the difference between setTimeout with 0ms delay and Promise.then()?

**Answer:**  
- **setTimeout(fn, 0)** → macrotask, executes **after the current call stack and all microtasks**.  
- **Promise.then()** → microtask, executes **before macrotasks**, immediately after the current stack.

---

### 💡 Example Code:
```js
setTimeout(() => console.log("timeout"), 0);
Promise.resolve().then(() => console.log("promise"));
console.log("sync");
// Output: sync, promise, timeout
```

### [🔝 Back to Top](#core-javascript)

## Question 95: What is the difference between flat() and flatMap()?

**Answer:**  
- **flat()** → flattens nested arrays to a specified depth.  
- **flatMap()** → first maps each element using a function, then flattens the result **one level deep**.

---

### 💡 Example Code:
```js
const arr = [1, 2, [3, 4]];
console.log(arr.flat());                  // [1, 2, 3, 4]
console.log([1, 2, 3].flatMap(x => [x, x*2])); // [1, 2, 2, 4, 3, 6]
```

### [🔝 Back to Top](#core-javascript)

## Question 96: What is the difference between Symbol() and String() as object keys?

**Answer:**  
- **Symbol()** → creates a unique key, cannot be accidentally overwritten or accessed.  
- **String()** → regular key, can be overwritten if duplicate.

---

### 💡 Example Code:
```js
const sym = Symbol("id");
const obj = {};
obj[sym] = 123;
obj["id"] = 456;

console.log(obj[sym]); // 123
console.log(obj["id"]); // 456
```

### [🔝 Back to Top](#core-javascript)

## Question 97: What is the difference between Object.seal() and Object.freeze()?

**Answer:**  
- **Object.seal()** → prevents adding or deleting properties, but existing properties can be modified.  
- **Object.freeze()** → prevents adding, deleting, or modifying properties; object becomes completely immutable.

---

### 💡 Example Code:
```js
const obj1 = {a:1};
Object.seal(obj1);
obj1.a = 2;      // ✅ works
// obj1.b = 3;   // ❌ ignored

const obj2 = {a:1};
Object.freeze(obj2);
// obj2.a = 5;   // ❌ ignored
// obj2.b = 2;   // ❌ ignored
```

### [🔝 Back to Top](#core-javascript)

## Question 98: What are Proxies in JavaScript and their use cases?

**Answer:**  
A **Proxy** allows you to intercept and customize operations performed on objects, such as property access, assignment, deletion, and function calls.

**Use Cases:**  
- Validation of property values.  
- Logging or debugging property access.  
- Reactive programming (e.g., frameworks like Vue.js).  
- Security or access control.  

---

### 💡 Example Code:
```js
const obj = { name: "Ritik" };

const proxy = new Proxy(obj, {
  get(target, key) {
    console.log(`Getting ${key}`);
    return target[key];
  },
  set(target, key, value) {
    console.log(`Setting ${key} to ${value}`);
    target[key] = value;
    return true;
  }
});

console.log(proxy.name); // Logs: "Getting name", then "Ritik"
proxy.name = "Patidar";  // Logs: "Setting name to Patidar"
```

### [🔝 Back to Top](#core-javascript)

## Question 99: What is the difference between Microtask and Macrotask?

**Answer:**  
- **Microtask:**  
  - Examples: `Promise` callbacks, `process.nextTick()` (Node.js).  
  - Executed **before** the next event loop tick, immediately after the current execution stack.  

- **Macrotask:**  
  - Examples: `setTimeout`, `setInterval`, I/O events.  
  - Executed **after** all microtasks have finished, in the next event loop tick.  

---

### 💡 Example Code:
```js
setTimeout(() => console.log("macrotask"), 0);
Promise.resolve().then(() => console.log("microtask"));

console.log("sync");
// Output:
// sync
// microtask
// macrotask
```

### [🔝 Back to Top](#core-javascript)

## Question 100: How to optimize performance in large JavaScript applications?

**Answer:**  
- Use **debouncing/throttling** for frequent events (scroll, resize, input).  
- **Lazy load modules** using dynamic `import()` to reduce initial load.  
- **Memoize expensive computations** to avoid recalculation.  
- **Avoid memory leaks** by removing event listeners and nullifying unused references.  
- Use **Web Workers** for heavy computations to keep the UI responsive.  
- Use **`requestAnimationFrame`** for smooth animations instead of `setTimeout` or `setInterval`.  

---

### 💡 Example Code (Debouncing):
```js
function debounce(fn, delay){
  let timer;
  return function(...args){
    clearTimeout(timer);
    timer = setTimeout(()=> fn.apply(this, args), delay);
  };
}

// Usage
window.addEventListener("resize", debounce(() => {
  console.log("Resized!");
}, 300));


### [🔝 Back to Top](#core-javascript)